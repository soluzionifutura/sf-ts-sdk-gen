import { readFileSync, ensureDirSync, writeFileSync } from "fs-extra"
import { parse } from "@soluzioni-futura/openapi2ts"
import { join } from "path"
import { OpenAPIV3_1 } from "openapi-types"

export type Options = { 
  openapi: OpenAPIV3_1.Document | string
  outputFolder: string
  sdkName?: string,
  sdkVersion?: string
}

export async function generateSdk({
  openapi,
  outputFolder,
  sdkName,
  sdkVersion,
}: Options): Promise<void> {
  if (typeof openapi === "string") {
    openapi = JSON.parse(readFileSync(openapi, "utf8")) as OpenAPIV3_1.Document
  }

  if (typeof sdkVersion !== "string") {
    sdkVersion = "0.1.0"
  }
  
  const openapiV3_1 = openapi as OpenAPIV3_1.Document
  const SDK_NAME = sdkName || `${openapiV3_1.info.title}-sdk`

  const _getFunctionCode = (params: {
    name: string, 
    path: string,
    description?: string
    requestType?: string
    responseType: string
    responseTypeName: string
  }): string => [
  params.description ? `/**\n${params.description}\n*/` : "",
  `export type ${params.responseTypeName} = ${params.responseType}`,
  `export async function ${params.name}(${params.requestType ? `data: ${params.requestType}, ` : ""}config?: AxiosRequestConfig): Promise<${params.responseTypeName}> {
  _checkSetup()
  const defaultConfig: AxiosRequestConfig = {
    headers: Object.assign(
      _getAuthHeader(),
      { "content-type": "application/json" }
    )
  }
  const res: ${params.responseTypeName} = await axios!.post(_getFnUrl("${params.name}"), ${params.requestType ? "data" : "undefined" }, config ? deepmerge(defaultConfig, config) : defaultConfig)
  return res
}`].filter(e => e).join("\n")

  ensureDirSync(join(outputFolder, "src"))
  
  // generate types
  const { data: typesCode,  exports: typesSet }  = await parse({
    openapi: openapiV3_1
  })

  // generate sdk

  const serverUrls = openapiV3_1.servers!.reduce((acc: { [env: string]: string }, { description, url }) => {
    if (!description) {
      throw new Error("All servers must have a description")
    }
    acc[description.toLowerCase()] = url
    return acc
  }, {})

  const securitySchemas = openapiV3_1.components?.securitySchemes || {}

  const sdk = [
  `/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/member-delimiter-style */
/**
 * This file was automatically generated by sf-ts-sdk-gen.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source
 * openapi definition and regenerate this file.
 */`,
    `import type { AxiosStatic, AxiosResponse, AxiosRequestConfig } from "axios"`,
    `import deepmerge from "deepmerge"`,
    "export const SDK_VERSION = \"" + sdkVersion + "\"",
    "export const API_VERSION = \"" + openapiV3_1.info.version + "\"",
    "export let axios: AxiosStatic | undefined = undefined",
    "export let env: string | undefined = undefined",
    `const _auth: { ${Object.keys(securitySchemas).map(e => `"${e}": string | null`)} } = { ${Object.keys(securitySchemas).map(e => `"${e}": null`).join(", ")} }`,
    `export function setAuth(securitySchemaName: keyof typeof _auth, value: string | null): void {
  if (typeof _auth[securitySchemaName] === "undefined") {
    throw new Error(\`Invalid security schema name: \${securitySchemaName}\`)
  }
  _auth[securitySchemaName] = value
}`,
    `function _getAuthHeader(): { [key: string]: string } {
  const headers: { [key: string]: string } = {}
  ${Object.entries(securitySchemas).map(([key, value]) => {
    value = value as OpenAPIV3_1.SecuritySchemeObject
    if (value.type === "http") {
      if (value.scheme === "bearer") {
        return `if (_auth["${key}"]) headers.Authorization = \`Bearer \${_auth["${key}"]}\``
      } else {
        return `if (_auth["${key}"]) headers.Authorization = \`Basic \${_auth["${key}"]}\``
      }
    } else if (value.type === "apiKey" && value.in === "header") {
      return `if (_auth["${key}"]) headers["${value.name}"] = _auth["${key}"]`
    }
    return ""
  }).filter(e => e).join("\n  ")}
  return headers
}`,
    `export const serverUrls: { [env: string]: string } = ${JSON.stringify(serverUrls, null, 2)}`,
    `function _getFnUrl(endpoint: string): string {
  const baseUrl = serverUrls[env!.toLowerCase()]
  if (!baseUrl) {
    throw new Error(\`Invalid env: \${env}\`)
  }

  return new URL(endpoint, baseUrl).href
}`,
    `export function setup(params: { axios: AxiosStatic, env: string, customServerUrls?: { [env: string]: string } }) {
  axios = params.axios
  env = params.env
  if (params.customServerUrls) {
    Object.assign(serverUrls, params.customServerUrls)
  }
  if (!serverUrls[env]) {
    throw new Error(\`Missing server url for env: \${env}\`)
  }
}`,
    `const _checkSetup = () => {
  if (!axios) {
    throw new Error("axios is not defined. Please set axios instance to the sdk.")
  }
  if (!env) {
    throw new Error("env is not defined. Please set env to the sdk.")
  }
}`,
    (await Promise.all(Object.entries(openapi.paths!).map(([path, pathItem]) => {
      // console.log(path, pathItem)
      if (!pathItem) {
        return
      }

      if (pathItem.post) {
        // TODO handle function paths
        const {
          parameters,
          description,
          operationId,
          security,
          requestBody,
          responses,
        } = pathItem.post

        let requestType
        
        if (requestBody) {
          const ref = (requestBody as OpenAPIV3_1.ReferenceObject).$ref
          if (!ref) {
            throw new Error(`requestBody.$ref is missing in POST ${path}; requestBody must be a $ref to a schema`)
          }
          
          const requestBodyRef = ref.split("/").pop()!
          if (!requestBodyRef) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; requestBody must be a $ref to a schema`)
          }
          
          const requestBodyDetails = openapiV3_1.components?.requestBodies?.[requestBodyRef] as OpenAPIV3_1.RequestBodyObject | undefined
          if (!requestBodyDetails) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; ${requestBodyRef} is not defined in components.requestBodies`)
          }

          const requestBodySchema = requestBodyDetails.content["application/json"]?.schema as OpenAPIV3_1.ReferenceObject | undefined
          if (!requestBodySchema) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; ${requestBodyRef} does not have an application/json schema`)
          }

          if (!requestBodySchema.$ref) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; ${requestBodyRef} application/json schema must be a $ref to a schema`)
          }

          const requestBodySchemaRef = requestBodySchema.$ref.split("/").pop()!
          if (!requestBodySchemaRef) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; ${requestBodySchema.$ref} must be a valid $ref to a schema`)
          }

          if (!typesSet.has(requestBodySchemaRef)) {
            throw new Error(`requestBody.$ref is invalid in POST ${path}; ${requestBodySchemaRef} has not been generated by openapi2ts`)
          }
          
          requestType = requestBodySchemaRef
        }
        
        if (!responses) {
          throw new Error(`responses is missing in POST ${path}`)
        }

        const responseType = Object.entries(responses).map(([statusCode, response]) => {
          const ref = (response as OpenAPIV3_1.ReferenceObject).$ref
          if (!ref) {
            throw new Error(`response.$ref is missing in POST ${path} ${statusCode}; response must be a $ref to a schema`)
          }
          
          const responseRef = ref.split("/").pop()!
          if (!responseRef) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; response must be a $ref to a schema`)
          }
          
          const responseDetails = openapiV3_1.components?.responses?.[responseRef] as OpenAPIV3_1.ResponseObject | undefined
          if (!responseDetails) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseRef} is not defined in components.responses`)
          }

          if (!responseDetails.content?.["application/json"]) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseRef} does not have an application/json content`)
          }

          const responseSchema = responseDetails.content?.["application/json"]?.schema as OpenAPIV3_1.ReferenceObject | undefined
          if (!responseSchema) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseRef} does not have an application/json schema`)
          }

          if (!responseSchema.$ref) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseRef} application/json schema must be a $ref to a schema`)
          }

          const responseSchemaRef = responseSchema.$ref.split("/").pop()!
          if (!responseSchemaRef) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseSchema.$ref} must be a valid $ref to a schema`)
          }

          if (!typesSet.has(responseSchemaRef)) {
            throw new Error(`response.$ref is invalid in POST ${path} ${statusCode}; ${responseSchemaRef} has not been generated by openapi2ts`)
          }
      
          const type = `(AxiosResponse<${responseSchemaRef}> & {
  ok: ${statusCode.startsWith("2") ? "true" : "false"}
  status: ${statusCode}
})`
          return type
        }).join(" | ")

        return _getFunctionCode({
          name: operationId!,
          description,
          path,
          requestType, 
          responseType,
          responseTypeName: `Axios${operationId!.replace(/([A-Z])/g, " $1").split(" ").map(e => e[0].toUpperCase() + e.slice(1)).join("")}Response`,
        })
      } else if (pathItem.get) {
        // TODO handle sse paths
        return ""
      }

      return ""
    }))).filter(e => e).join("\n\n"),
    typesCode
  ].join("\n\n")

  // const exports = new Set<string>()

  // const data = bannerComment + (await Promise.all(Object.entries(openapi.components!.schemas!).map(([name, schema]) => {
  //   if (exports.has(name)) {
  //     throw new Error(`Duplicate schema name: ${name}`)
  //   }

  // }))).join("\n")

  writeFileSync(join(outputFolder, "src", "index.ts"), sdk)

  const pkgLicense = "MIT"
  const engines = {
    "node": ">=10"
  }
  const author = "sf-ts-sdk-gen"
  
  const buildPackageJson = {
    "version": sdkVersion,
    "license": pkgLicense,
    "main": "./index.js",
    "typings": "./index.d.ts",
    engines,
    author,
    "module": `./${SDK_NAME}.esm.js`,
    "sideEffects": false,
  }
  const packageJson = {
    "version": sdkVersion,
    "license": pkgLicense,
    "main": "dist/index.js",
    "typings": `dist/index.d.ts`,
    "files": [
      "dist",
      "src"
    ],
    engines,
    "scripts": {
      "build": "tsdx build && npm run build:package",
      "lint": "tsdx lint",
      "prepare": "tsdx build && npm run build:package",
      "size": "size-limit",
      "analyze": "size-limit --why",
      "build:package": `echo '${JSON.stringify(buildPackageJson)}' > dist/package.json`,
    },
    "name": SDK_NAME,
    author,
    "module": `dist/${SDK_NAME}.esm.js`,
    "sideEffects": false,
    "devDependencies": {
      "@size-limit/preset-small-lib": "^8.2.4",
      "@types/fs-extra": "^11.0.1",
      "husky": "^8.0.3",
      "openapi-types": "^12.1.0",
      "size-limit": "^8.2.4",
      "tsdx": "^0.14.1",
      "tslib": "^2.5.0",
      "typescript": "^3.9.10",
      "axios": "^1.3.4"
    },
    "dependencies": {
      "deepmerge": "4.3.0"
    }
  }

  writeFileSync(join(outputFolder, "package.json"), JSON.stringify(packageJson, null, 2))

  const tsconfig = {
    "include": ["src", "types"],
    "compilerOptions": {
      "module": "esnext",
      "lib": ["dom", "esnext"],
      "importHelpers": true,
      "declaration": true,
      "sourceMap": true,
      "rootDir": "./src",
      "strict": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "noUnusedLocals": false,
      "noUnusedParameters": false,
      "moduleResolution": "node",
      "jsx": "react",
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "noEmit": true,
    }
  }

  writeFileSync(join(outputFolder, "tsconfig.json"), JSON.stringify(tsconfig, null, 2))

  const license = `MIT License
  
Copyright (c) ${new Date().getFullYear()} Soluzioni Futura

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`

  writeFileSync(join(outputFolder, "LICENSE"), license)

  const gitignore = `*.log
.DS_Store
node_modules
dist`

  writeFileSync(join(outputFolder, ".gitignore"), gitignore)
}

